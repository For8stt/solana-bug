// File: /Applications/StudySTU/Solana/ackee/TridentCompilation/test-bug-alexar/trident-arena-compilation-container/test-axelar/audit-axelar-solana-241-master/solana/programs/axelar-solana-gas-service/src/entrypoint.rs
//! Program entrypoint

#![cfg(all(target_os = "solana", not(feature = "no-entrypoint")))]

use crate::processor::process_instruction;

solana_program::entrypoint!(process_instruction);


// Entrypoint Function: /Applications/StudySTU/Solana/ackee/TridentCompilation/test-bug-alexar/trident-arena-compilation-container/test-axelar/audit-axelar-solana-241-master/solana/programs/axelar-solana-gas-service/src/processor.rs

#[allow(clippy::todo)]
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo<'_>],
    input: &[u8],
) -> ProgramResult {
    let instruction = GasServiceInstruction::try_from_slice(input)?;
    check_program_account(*program_id)?;

    match instruction {
        GasServiceInstruction::Initialize { salt } => {
            process_initialize_config(program_id, accounts, salt)
        }
        GasServiceInstruction::SplToken(ix) => match ix {
            PayWithSplToken::ForContractCall {
                destination_chain,
                destination_address,
                payload_hash,
                gas_fee_amount,
                params,
                decimals,
                refund_address,
            } => process_pay_spl_for_contract_call(
                program_id,
                accounts,
                destination_chain,
                destination_address,
                payload_hash,
                refund_address,
                &params,
                gas_fee_amount,
                decimals,
            ),
            PayWithSplToken::AddGas {
                tx_hash,
                log_index,
                gas_fee_amount,
                decimals,
                refund_address,
            } => add_spl_gas(
                program_id,
                accounts,
                tx_hash,
                log_index,
                gas_fee_amount,
                refund_address,
                decimals,
            ),
            PayWithSplToken::CollectFees { amount, decimals } => {
                collect_fees_spl(program_id, accounts, amount, decimals)
            }
            PayWithSplToken::Refund {
                tx_hash,
                log_index,
                fees,
                decimals,
            } => refund_spl(program_id, accounts, tx_hash, log_index, fees, decimals),
        },
        GasServiceInstruction::Native(ix) => match ix {
            PayWithNativeToken::ForContractCall {
                destination_chain,
                destination_address,
                payload_hash,
                refund_address,
                params,
                gas_fee_amount,
            } => process_pay_native_for_contract_call(
                program_id,
                accounts,
                destination_chain,
                destination_address,
                payload_hash,
                refund_address,
                &params,
                gas_fee_amount,
            ),
            PayWithNativeToken::AddGas {
                tx_hash,
                log_index,
                gas_fee_amount,
                refund_address,
            } => add_native_gas(
                program_id,
                accounts,
                tx_hash,
                log_index,
                gas_fee_amount,
                refund_address,
            ),
            PayWithNativeToken::CollectFees { amount } => {
                collect_fees_native(program_id, accounts, amount)
            }
            PayWithNativeToken::Refund {
                tx_hash,
                log_index,
                fees,
            } => refund_native(program_id, accounts, tx_hash, log_index, fees),
        },
    }
}

// Dispatch Function: /Applications/StudySTU/Solana/ackee/TridentCompilation/test-bug-alexar/trident-arena-compilation-container/test-axelar/audit-axelar-solana-241-master/solana/programs/axelar-solana-gas-service/src/processor/initialize.rs

pub(crate) fn process_initialize_config(
    program_id: &Pubkey,
    accounts: &[AccountInfo<'_>],
    salt: [u8; 32],
) -> ProgramResult {
    let accounts = &mut accounts.iter();
    let payer = next_account_info(accounts)?;
    let authority = next_account_info(accounts)?;
    let config_pda = next_account_info(accounts)?;
    let system_account = next_account_info(accounts)?;

    // Check: System Program Account
    if !system_program::check_id(system_account.key) {
        return Err(ProgramError::InvalidInstructionData);
    }

    if !authority.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    let (_, bump) = get_config_pda(program_id, &salt, authority.key);

    // Check: Gateway Config account uses the canonical bump.
    assert_valid_config_pda(bump, &salt, authority.key, config_pda.key)?;

    // Initialize the account
    program_utils::init_pda_raw(
        payer,
        config_pda,
        program_id,
        system_account,
        size_of::<Config>().try_into().expect("must be valid u64"),
        &[
            seed_prefixes::CONFIG_SEED,
            &salt,
            authority.key.as_ref(),
            &[bump],
        ],
    )?;
    let mut data = config_pda.try_borrow_mut_data()?;
    let gateway_config = Config::read_mut(&mut data).ok_or(ProgramError::InvalidAccountData)?;

    *gateway_config = Config {
        bump,
        authority: *authority.key,
        salt,
    };

    Ok(())
}

// Dispatch Function: /Applications/StudySTU/Solana/ackee/TridentCompilation/test-bug-alexar/trident-arena-compilation-container/test-axelar/audit-axelar-solana-241-master/solana/programs/axelar-solana-gas-service/src/processor/spl.rs

pub(crate) fn process_pay_spl_for_contract_call(
    program_id: &Pubkey,
    accounts: &[AccountInfo<'_>],
    destination_chain: String,
    destination_address: String,
    payload_hash: [u8; 32],
    refund_address: Pubkey,
    params: &[u8],
    gas_fee_amount: u64,
    decimals: u8,
) -> ProgramResult {
    if gas_fee_amount == 0 {
        msg!("Gas fee amount cannot be zero");
        return Err(ProgramError::InvalidInstructionData);
    }

    let (accounts, signer_pubkeys) = accounts.split_at(6);
    let accounts = &mut accounts.iter();
    let sender = next_account_info(accounts)?;
    let sender_ata = next_account_info(accounts)?;
    let config_pda = next_account_info(accounts)?;
    let config_pda_ata = next_account_info(accounts)?;
    let mint = next_account_info(accounts)?;
    let token_program = next_account_info(accounts)?;

    // Ensure config_pda is valid
    ensure_valid_config_pda(config_pda, program_id)?;

    // valid token program
    spl_token_2022::check_spl_token_program_account(token_program.key)?;

    // ensure config_pda_ata is owned by the Token Program and matches expected fields
    ensure_valid_config_pda_ata(config_pda_ata, token_program, mint, config_pda)?;

    let ix = transfer_tokens(
        token_program,
        sender_ata,
        mint,
        config_pda_ata,
        sender,
        signer_pubkeys,
        gas_fee_amount,
        decimals,
    )?;

    invoke(
        &ix,
        &[
            sender.clone(),
            mint.clone(),
            sender_ata.clone(),
            config_pda_ata.clone(),
            token_program.clone(),
        ],
    )?;

    // Emit an event
    sol_log_data(&[
        event_prefixes::SPL_PAID_FOR_CONTRACT_CALL,
        &config_pda.key.to_bytes(),
        &config_pda_ata.key.to_bytes(),
        &mint.key.to_bytes(),
        &token_program.key.to_bytes(),
        &destination_chain.into_bytes(),
        &destination_address.into_bytes(),
        &payload_hash,
        &refund_address.to_bytes(),
        params,
        &gas_fee_amount.to_le_bytes(),
    ]);

    Ok(())
}

// Dispatch Function: /Applications/StudySTU/Solana/ackee/TridentCompilation/test-bug-alexar/trident-arena-compilation-container/test-axelar/audit-axelar-solana-241-master/solana/programs/axelar-solana-gas-service/src/processor/native.rs

pub(crate) fn process_pay_native_for_contract_call(
    program_id: &Pubkey,
    accounts: &[AccountInfo<'_>],
    destination_chain: String,
    destination_address: String,
    payload_hash: [u8; 32],
    refund_address: Pubkey,
    params: &[u8],
    gas_fee_amount: u64,
) -> ProgramResult {
    if gas_fee_amount == 0 {
        msg!("Gas fee amount cannot be zero");
        return Err(ProgramError::InvalidInstructionData);
    }

    let accounts = &mut accounts.iter();
    let sender = next_account_info(accounts)?;
    let config_pda = next_account_info(accounts)?;
    let system_program = next_account_info(accounts)?;

    try_load_config(program_id, config_pda)?;

    invoke(
        &system_instruction::transfer(sender.key, config_pda.key, gas_fee_amount),
        &[sender.clone(), config_pda.clone(), system_program.clone()],
    )?;

    // Emit an event
    sol_log_data(&[
        event_prefixes::NATIVE_GAS_PAID_FOR_CONTRACT_CALL,
        &config_pda.key.to_bytes(),
        &destination_chain.into_bytes(),
        &destination_address.into_bytes(),
        &payload_hash,
        &refund_address.to_bytes(),
        params,
        &gas_fee_amount.to_le_bytes(),
    ]);

    Ok(())
}